// --------------------------------------------------------------------------------------------
// The following code is automatically generated by the gen-mongo-dao tool. 
// Please do not modify this code manually to avoid being overwritten in the next generation. 
// For more tool details, please click the link to view https://github.com/dobyte/gen-mongo-dao
// --------------------------------------------------------------------------------------------

package internal

import (
	"context"
	"errors"
	"example/model/user"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"time"
)

type UserFilterFunc func(cols *UserColumns) interface{}
type UserUpdateFunc func(cols *UserColumns) interface{}
type UserFindOneOptionsFunc func(cols *UserColumns) *options.FindOneOptions
type UserFindManyOptionsFunc func(cols *UserColumns) *options.FindOptions
type UserUpdateOptionsFunc func(cols *UserColumns) *options.UpdateOptions
type UserDeleteOptionsFunc func(cols *UserColumns) *options.DeleteOptions
type UserInsertOneOptionsFunc func(cols *UserColumns) *options.InsertOneOptions
type UserInsertManyOptionsFunc func(cols *UserColumns) *options.InsertManyOptions

type User struct {
	Columns    *UserColumns
	Database   *mongo.Database
	Collection *mongo.Collection
}

type UserColumns struct {
	ID             string
	UID            string
	Account        string
	Password       string
	Salt           string
	Mobile         string
	Email          string
	Nickname       string
	Signature      string
	Gender         string
	Level          string
	Experience     string
	Coin           string
	Type           string
	Status         string
	DeviceID       string
	ThirdPlatforms string
	RegisterIP     string
	RegisterTime   string
	LastLoginIP    string
	LastLoginTime  string
}

var userColumns = &UserColumns{
	ID:             "_id",
	UID:            "uid",
	Account:        "account",
	Password:       "password",
	Salt:           "salt",
	Mobile:         "mobile",
	Email:          "email",
	Nickname:       "nickname",
	Signature:      "signature",
	Gender:         "gender",
	Level:          "level",
	Experience:     "experience",
	Coin:           "coin",
	Type:           "type",
	Status:         "status",
	DeviceID:       "device_id",
	ThirdPlatforms: "third_platforms",
	RegisterIP:     "register_ip",
	RegisterTime:   "register_time",
	LastLoginIP:    "last_login_ip",
	LastLoginTime:  "last_login_time",
}

func NewUser(db *mongo.Database) *User {
	return &User{
		Columns:    userColumns,
		Database:   db,
		Collection: db.Collection("user"),
	}
}

// InsertOne executes an insert command to insert a single document into the collection.
func (dao *User) InsertOne(ctx context.Context, model *user.User, optionsFunc ...UserInsertOneOptionsFunc) (*mongo.InsertOneResult, error) {
	if model == nil {
		return nil, errors.New("model is nil")
	}

	if err := dao.autofill(ctx, model); err != nil {
		return nil, err
	}

	var opts *options.InsertOneOptions

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	return dao.Collection.InsertOne(ctx, model, opts)
}

// InsertMany executes an insert command to insert multiple documents into the collection.
func (dao *User) InsertMany(ctx context.Context, models []*user.User, optionsFunc ...UserInsertManyOptionsFunc) (*mongo.InsertManyResult, error) {
	if len(models) == 0 {
		return nil, errors.New("models is empty")
	}

	documents := make([]interface{}, 0, len(models))
	for i := range models {
		model := models[i]
		if err := dao.autofill(ctx, model); err != nil {
			return nil, err
		}
		documents = append(documents, model)
	}

	var opts *options.InsertManyOptions

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	return dao.Collection.InsertMany(ctx, documents, opts)
}

// UpdateOne executes an update command to update at most one document in the collection.
func (dao *User) UpdateOne(ctx context.Context, filterFunc UserFilterFunc, updateFunc UserUpdateFunc, optionsFunc ...UserUpdateOptionsFunc) (*mongo.UpdateResult, error) {
	var (
		opts   *options.UpdateOptions
		filter = filterFunc(dao.Columns)
		update = updateFunc(dao.Columns)
	)

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	return dao.Collection.UpdateOne(ctx, filter, update, opts)
}

// UpdateOneByID executes an update command to update at most one document in the collection.
func (dao *User) UpdateOneByID(ctx context.Context, id string, updateFunc UserUpdateFunc, optionsFunc ...UserUpdateOptionsFunc) (*mongo.UpdateResult, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

    return dao.UpdateOne(ctx, func(cols *UserColumns) interface{} {
		return bson.M{"_id": objectID}
	}, updateFunc, optionsFunc...)
}

// UpdateMany executes an update command to update documents in the collection.
func (dao *User) UpdateMany(ctx context.Context, filterFunc UserFilterFunc, updateFunc UserUpdateFunc, optionsFunc ...UserUpdateOptionsFunc) (*mongo.UpdateResult, error) {
	var (
		opts   *options.UpdateOptions
		filter = filterFunc(dao.Columns)
		update = updateFunc(dao.Columns)
	)

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	return dao.Collection.UpdateMany(ctx, filter, update, opts)
}

// FindOne executes a find command and returns a model for one document in the collection.
func (dao *User) FindOne(ctx context.Context, filterFunc UserFilterFunc, optionsFunc ...UserFindOneOptionsFunc) (*user.User, error) {
	var (
		opts   *options.FindOneOptions
		model  = &user.User{}
		filter = filterFunc(dao.Columns)
	)

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	err := dao.Collection.FindOne(ctx, filter, opts).Decode(model)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}

	return model, nil
}

// FindOneByID executes a find command and returns a model for one document in the collection.
func (dao *User) FindOneByID(ctx context.Context, id string, optionsFunc ...UserFindOneOptionsFunc) (*user.User, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

    return dao.FindOne(ctx, func(cols *UserColumns) interface{} {
		return bson.M{"_id": objectID}
	}, optionsFunc...)
}

// FindMany executes a find command and returns many models the matching documents in the collection.
func (dao *User) FindMany(ctx context.Context, filterFunc UserFilterFunc, optionsFunc ...UserFindManyOptionsFunc) ([]*user.User, error) {
	var (
		opts   *options.FindOptions
		filter = filterFunc(dao.Columns)
	)

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	cur, err := dao.Collection.Find(ctx, filter, opts)
	if err != nil {
		return nil, err
	}

	models := make([]*user.User, 0)
	
	if err = cur.All(ctx, &models); err != nil {
		return nil, err
	}

	return models, nil
}

// DeleteOne executes a delete command to delete at most one document from the collection.
func (dao *User) DeleteOne(ctx context.Context, filterFunc UserFilterFunc, optionsFunc ...UserDeleteOptionsFunc) (*mongo.DeleteResult, error) {
	var (
		opts   *options.DeleteOptions
		filter = filterFunc(dao.Columns)
	)

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	return dao.Collection.DeleteOne(ctx, filter, opts)
}

// DeleteOneByID executes a delete command to delete at most one document from the collection.
func (dao *User) DeleteOneByID(ctx context.Context, id string, optionsFunc ...UserDeleteOptionsFunc) (*mongo.DeleteResult, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

    return dao.DeleteOne(ctx, func(cols *UserColumns) interface{} {
		return bson.M{"_id": objectID}
	}, optionsFunc...)
}

// DeleteMany executes a delete command to delete documents from the collection.
func (dao *User) DeleteMany(ctx context.Context, filterFunc UserFilterFunc, optionsFunc ...UserDeleteOptionsFunc) (*mongo.DeleteResult, error) {
	var (
		opts   *options.DeleteOptions
		filter = filterFunc(dao.Columns)
	)

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	return dao.Collection.DeleteMany(ctx, filter, opts)
}

// autofill when inserting data
func (dao *User) autofill(ctx context.Context, model *user.User) error {
	if model.ID.IsZero() {
		model.ID = primitive.NewObjectID()
	}

	if model.UID == 0 {
		if id, err := NewCounter(dao.Database).Incr(ctx, "uid"); err != nil {
			return err
		} else {
			model.UID = int32(id)
		}
	}

	if model.RegisterTime == 0 {
		model.RegisterTime = primitive.NewDateTimeFromTime(time.Now())
	}

	if model.LastLoginTime == 0 {
		model.LastLoginTime = primitive.NewDateTimeFromTime(time.Now())
	}

	return nil
}
